/**
  * Copyright 2015, 2016, 2017 Gianluca Amato <gianluca.amato@unich.it>
  *
  * This file is part of ScalaFix.
  * ScalaFix is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * ScalaFix is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty ofa
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with ScalaFix.  If not, see <http://www.gnu.org/licenses/>.
  */

package it.unich.scalafix.finite

import it.unich.scalafix._
import it.unich.scalafix.lattice.Domain
import it.unich.scalafix.utils.Relation

import scala.collection.mutable

/**
  * This is the abstract class for a finite equation system generated by an hyper-graph. Unknowns are nodes
  * of the graph and each hyper-edge has a single target and many possible sources. Given an assignment, each
  * hyper-edge produces a partial values. These values are combined with the upper bound operation.
  */
abstract class GraphEquationSystem[U, V, E](implicit val dom: Domain[V]) extends FiniteEquationSystem[U, V] {
  /**
    * A function which, given an assignment and edge, returns the output value of
    * the edge.
    */
  val edgeAction: Assignment[U, V] => E => V

  /**
    * Maps each edge to its sources unknown.
    */
  val sources: E => Iterable[U]

  /**
    * Maps each edge to its target unknown.
    */
  val target: E => U

  /**
    * Maps each unknown to the collection of edges departing from it.
    */
  val outgoing: U => Iterable[E]

  /**
    * Maps each unknown to the collection of edges arriving on it.
    */
  val ingoing: U => Iterable[E]

  /**
    * Add boxes to the equation system in a localized way.
    *
    * @param boxes    new box to add.
    * @param ordering an order on unknowns in order to decide which edges needs to be widened
    */
  def withLocalizedBoxes(boxes: BoxAssignment[U, V], ordering: Ordering[U]): GraphEquationSystem[U, V, E]

  /**
    * Add warrowing to the equation system in a localized way. Localized warrowing requires a different
    * procedure than standard localized widenings. Moreover, it is not entirely clear whether this works as
    * intended or not.
    *
    * @param widenings  a widenings assignment
    * @param narrowings a narrowings assignment
    */
  def withLocalizedWarrowing(widenings: BoxAssignment[U, V], narrowings: BoxAssignment[U, V], ordering: Ordering[U]): FiniteEquationSystem[U, V]
}

case class SimpleGraphEquation[U, V: Domain, E](
                                                 unknowns: Iterable[U],
                                                 inputUnknowns: Set[U],
                                                 edgeAction: Assignment[U, V] => E => V,
                                                 sources: E => Iterable[U],
                                                 target: E => U,
                                                 outgoing: U => Iterable[E],
                                                 ingoing: U => Iterable[E],
                                                 initial: Assignment[U, V],
                                                 boxAssignment: BoxAssignment[U, V] = BoxAssignment.empty,
                                                 baseAssignment: PartialFunction[U, V] = PartialFunction.empty,
                                                 tracer: EquationSystemTracer[U, V] = EquationSystemTracer.empty,
                                                 boxesAreLocalized: Boolean = false,
                                                 ordering: Ordering[U] = ???
                                               ) extends GraphEquationSystem[U, V, E] {

  def apply(rho: Assignment[U, V], u: U) = {
    tracer.preEvaluation(rho, u)
    val contributions = if (boxesAreLocalized && boxAssignment.isDefinedAt(u)) {
      // case in which localized box has to be applied
      for (e <- ingoing(u)) yield
        if (sources(e).exists(ordering.lteq(u, _)))
          boxAssignment(u)(rho(u), edgeAction(rho)(e))
        else
          edgeAction(rho)(e)
    } else {
      // case in which localized box must not be applied
      for (e <- ingoing(u)) yield edgeAction(rho)(e)
    }
    // if contribution is empty the unknown x has no right hand side... it seems
    // reasonable to return the old value.
    var bodyRes = if (contributions.isEmpty)
      rho(u)
    else
      contributions reduce dom.upperBound
    val res = if (baseAssignment.isDefinedAt(u))
      bodyRes
    else
      magma.op(bodyRes, baseAssignment(u))
    tracer.postEvaluation(rho, u, res)
    if (!boxesAreLocalized && boxAssignment.isDefinedAt(u)) {
      val boxedRes = boxAssignment(u)(rho(u), res)
      tracer.boxEvaluation(rho, u, res, boxedRes)
      boxedRes
    } else {
      tracer.noBoxEvaluation(rho, u, res)
      res
    }
  }

  def applyWithDependencies(rho: Assignment[U, V], u: U): (V, Iterable[U]) = {
    val deps = ingoing(u).foldLeft(Iterable.empty[U])((acc: Iterable[U], e: E) => acc ++ sources(e))
    val res = apply(rho, u)
    (res, deps)
  }

  def infl(u: U) = {
    // we do not check whether, in the localized case, we actually apply widening
    val edgeInfl = (for (e <- outgoing(u)) yield target(e)) (collection.breakOut)
    if (boxAssignment.boxesAreIdempotent || !boxAssignment.isDefinedAt(u))
      edgeInfl
    else
      u +: edgeInfl
  }

  def withLocalizedBoxes(boxes: BoxAssignment[U, V], ordering: Ordering[U]): GraphEquationSystem[U, V, E] =
    copy (boxAssignment = boxes, ordering = ordering, boxesAreLocalized = true)

  def withBoxes(boxes: BoxAssignment[U, V]): GraphEquationSystem[U, V, E] =
    copy (boxAssignment = boxes, boxesAreLocalized = false)

  def withLocalizedWarrowing(widenings: BoxAssignment[U, V], narrowings: BoxAssignment[U, V], ordering: Ordering[U]): FiniteEquationSystem[U, V] =




}

object GraphEquationSystem {

  def withLocalizedWarrowing(widenings: BoxAssignment[U, V], narrowings: BoxAssignment[U, V], ordering: Ordering[U]): FiniteEquationSystem[U, V] = {
      val newbody = new Body[U, V] {
        def apply(rho: Assignment[U, V]) = {
          (x: U) =>
            val contributions = for (e <- ingoing(x)) yield {
              val contrib = edgeAction(rho)(e)
              val boxapply = sources(e).exists(ordering.lteq(x, _)) && !dom.lteq(contrib, rho(x))
              (contrib, boxapply)
            }
            // if contribution is empty the unknown x has no right hand side... it seems
            // reasonable to return the old value.
            if (contributions.isEmpty)
              rho(x)
            else {
              val result = contributions reduce { (x: (V, Boolean), y: (V, Boolean)) => (dom.upperBound(x._1, y._1), x._2 || y._2) }
              //println((x, rho(x), contributions))
              if (result._2) {
                widenings(x)(rho(x), result._1)
              } else if (dom.lt(result._1, rho(x))) narrowings(x)(rho(x), result._1) else result._1
            }
        }
      }

      FiniteEquationSystem(
        body = newbody,
        initial = initial,
        inputUnknowns = inputUnknowns,
        unknowns = unknowns,
        infl = if (widenings.boxesAreIdempotent && narrowings.boxesAreIdempotent) infl else infl.withDiagonal
      )
    }

  }
