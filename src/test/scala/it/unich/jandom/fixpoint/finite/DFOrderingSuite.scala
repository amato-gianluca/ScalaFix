/**
 * Copyright 2015 Gianluca Amato <gamato@unich.it>
 *
 * This file is part of JANDOM: JVM-based Analyzer for Numerical DOMains
 * JANDOM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JANDOM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty ofa
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JANDOM.  If not, see <http://www.gnu.org/licenses/>.
 */

package it.unich.jandom.fixpoint.finite

import scala.collection.immutable.ListSet

import org.scalatest.FunSpec
import org.scalatest.prop.PropertyChecks

import DFOrdering.EdgeType._
import it.unich.jandom.utils.Relation

class DFOrderingSuite extends FunSpec with PropertyChecks {
  import DFOrdering.EdgeType._

  // This example comes from "Aho, Sethi, Ullman - Compilers: Principles, Techniques and Tool - Addison Wesley"
  val graph = Relation[Int, Int](ListSet(1 -> 3, 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 6, 4 -> 5, 4 -> 8, 5 -> 7, 6 -> 7, 7 -> 4, 7 -> 8, 8 -> 4, 8 -> 3, 8 -> 10, 8 -> 9, 9 -> 1, 10 -> 7))
  val heads = Set(1, 3, 4, 7)
  val sequence = 1 to 10
  val advancing = Set(1 -> 2, 1 -> 3, 3 -> 4, 4 -> 5, 4 -> 6, 6 -> 7, 7 -> 8, 8 -> 9, 8 -> 10, 4 -> 8)
  val retreating = Set(10 -> 7, 9 -> 1, 8 -> 3, 7 -> 4, 4 -> 3)
  val cross = Set(2 -> 3, 5 -> 7)

  val graph2 = Relation[Int, Int](ListSet(1 -> 2, 1 -> 3, 2 -> 3, 3 -> 4, 4 -> 6, 4 -> 5, 4 -> 8, 5 -> 7, 6 -> 7, 7 -> 4, 7 -> 8, 8 -> 4, 8 -> 3, 8 -> 9, 8 -> 10, 9 -> 1, 10 -> 7))
  val sequence2 = (1 to 8).toList :+ 10 :+ 9

  describe("The depth-first ordering generated by the example graph") {
    val o = DFOrdering(graph)(1)

    it("has the correct sequence") {
      assertResult(sequence) { o.toSeq }
    }
    it("has the correct heads") {
      assertResult(heads) { o.heads }
      for (x <- sequence) assertResult(heads contains x) { o.isHead(x) }
    }
    it("has the correct edge types") {
      for ((u, v) <- advancing) { assertResult(Advancing) { o.edgeType(u, v) } }
      for ((u, v) <- retreating) { assertResult(Retreating) { o.edgeType(u, v) } }
      for ((u, v) <- cross) { assertResult(Cross) { o.edgeType(u, v) } }
    }
    it("implements the correct ordering") {
      for (x <- sequence; y <- sequence) {
        assertResult(scala.math.signum(sequence.indexOf(x) compare sequence.indexOf(y))) { scala.math.signum(o.compare(x, y)) }
      }
    }
  }
  
  describe("The depth-first ordering generated by a permutation of the example graph") {
    it("has a different ordering of elements") {
      val o2 = DFOrdering(graph2)(1)
      assertResult(sequence2) { o2.toSeq }
    }
  }
}
